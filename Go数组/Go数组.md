#### 数组

数组是一种非常有用的数据结构，因为其占用的内存是连续分配的。由于内存连续，CPU能把正在使用的数据缓存更久的时间。而且内存连续很容易计算索引，可以快速迭代数组里的所有元素。数组的类型信息可以提供每次访问一个元素时需要在内存中移动的距离。既然数组的每个元素类型相同，又是连续分配，就可以以固定速度索引数组中的任意数据，速度非常快。

注意：在 Go 中数组是值类型而不是引用类型。这意味着当数组变量被赋值时，将会获得原数组的拷贝。新数组中元素的改变不会影响原数组中元素的值。


##### 声明和赋值方式

###### 声明
```go
var array[5] int
```
###### 使用具体值初始化
```go
array :=[5] int {} //[0,0,0,0,0]
```
```go
array :=[5] int {10,20,30,40,50} //[10,20,30,40,50]
```
```go
// 声明一个整型数组
// 用具体值初始化每个元素
// 容量由初始化值的数量决定
array := [...]int{10, 20, 30, 40, 50}
```

```go
// 声明一个有5个元素的数组
// 用具体值初始化索引为1和2的元素
// 其余元素保持零值
array := [5]int{1: 10, 2: 20}
```
##### 循环一个数组
注意数组是基本类型，这意味着循环数组并不像js中数组也是一个对象，直接调用array.length进行循环。

###### for循环
```go
array :=[5]int{0:1, 1:1}
array[0]=1
for i:=0;i<5;i++{
    fmt.Printf("%d",array[i])
}
fmt.Printf("\n")
```

###### range循环
```go
array :=[5]int{0:1, 1:1}
//array为[1,1,0,0,0]

for index,value:= range array{
    fmt.Printf("index:%d,value:%d\n",index,value)
}
```

##### 指针数组
指针数组和普通数组基本一样,注意，赋值前一定要先给指针赋值一个地址。

```go
array :=[5]*int{0: new(int), 1: new(int)}
*array[0]=1 // 赋值成功
*array[2]=1 // 报错，因为*array[2]指向一个nil指针
fmt.Printf("%d",*array[0]) // 1
```

```go
array :=[5]*int{}
array[0]=new(int) // 先给指针一个地址
*array[0]=1       // 然后才能赋值
fmt.Printf("%d",*array[0]) // 1
```

##### 多维数组
多维数组的写法：
```go
array :=[5][3]int{0:{11,22,33}, 1:{44,55,66}}
/*array为[
    [11,22,33],
    [44,55,66],
    [0,0,0],
    [0,0,0],
    [0,0,0],
]*/
for i:=0;i<5;i++{
    for j:=0;j<3;j++{
        fmt.Printf("[%d][%d]=%d\n",i,j,array[i][j])
    }
}
fmt.Printf("\n")
//或者使用range循环
for i,v1:=range array{
    for j,v2:= range v1{
        fmt.Printf("[%d][%d]=%d\n",i,j,v2)
    }
}
```

##### 关于函数中传递一个数组的思考
函数中如果一参数是数组的话会有什么问题？

在go语言中，数组是基本类型，不是引用类型，所以传递的都是值。

想象一下一个动态数组比如切片作为一个形参传进一个函数，那么这个函数中切片形参占用只是一个指针，大概几个字节。

那如果传进一个很大的数组呢？

那么这个数组有多大，函数的形参就必须有多大，在一些极端的情况下就会有性能问题。

解决办法就是传入数组的指针。



